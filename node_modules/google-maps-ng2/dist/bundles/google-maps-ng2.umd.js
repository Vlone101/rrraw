(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
	(factory((global.ng = global.ng || {}, global.ng['google-maps-ng2'] = global.ng['google-maps-ng2'] || {}),global.ng.core));
}(this, (function (exports,_angular_core) { 'use strict';

var BaseGoogleMapComponent = (function () {
    function BaseGoogleMapComponent() {
        var _this = this;
        this.proxy = new Promise(function (resolve) { return _this.proxyResolver = resolve; });
    }
    BaseGoogleMapComponent.prototype.hasMapComponent = function () {
        return !!this.mapComponent;
    };
    BaseGoogleMapComponent.prototype.setMapComponent = function (component, map) {
        var _this = this;
        this.mapComponent = component;
        this.proxy.then(function (googleApiEntity) { return setTimeout(function () { return googleApiEntity.setMap && googleApiEntity.setMap(map); }, _this.delay || 0); });
    };
    return BaseGoogleMapComponent;
}());

/**
 * Created by mjaric on 9/28/16.
 */
var BaseGoogleMapsApiLoader = (function () {
    function BaseGoogleMapsApiLoader() {
    }
    return BaseGoogleMapsApiLoader;
}());

var ScriptLoaderProtocol = {
    AUTO: 'auto',
    HTTP: 'http',
    HTTPS: 'https'
};

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$1 = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Created by mjaric on 9/28/16.
 */
var LAZY_LOADER_OPTIONS = new _angular_core.OpaqueToken('_gmapsng2.LazyLoaderGoogleMapsApiOptions');
var LOADER_OPTIONS_DEFAULT = {
    apiVersion: 3,
    protocol: ScriptLoaderProtocol.AUTO,
    hostAndPath: 'maps.googleapis.com/maps/api/js',
    libraries: []
};
exports.LazyGoogleMapsApiLoader = (function (_super) {
    __extends(LazyGoogleMapsApiLoader, _super);
    function LazyGoogleMapsApiLoader(options) {
        var _this = _super.call(this) || this;
        _this._options = Object.assign({}, LOADER_OPTIONS_DEFAULT, options);
        return _this;
    }
    LazyGoogleMapsApiLoader.prototype.load = function () {
        if (this._promise) {
            return this._promise;
        }
        return this._promise = this.createPromise();
    };
    LazyGoogleMapsApiLoader.prototype.createPromise = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var callbackName = "_gmi" + new Date().getTime();
            window[callbackName] = resolve;
            document.body.appendChild(_this.createScript(callbackName, reject));
        });
    };
    LazyGoogleMapsApiLoader.prototype.createScript = function (callbackName, onError) {
        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = this.createScriptUrl(callbackName);
        script.async = true;
        script.defer = true;
        script.onerror = onError;
        return script;
    };
    LazyGoogleMapsApiLoader.prototype.createScriptUrl = function (callbackName) {
        return this.getProtocol() + "//" + this._options.hostAndPath + this.getQueryParams(callbackName);
    };
    LazyGoogleMapsApiLoader.prototype.getProtocol = function () {
        switch (this._options.protocol) {
            case ScriptLoaderProtocol.AUTO:
                return '';
            case ScriptLoaderProtocol.HTTP:
                return 'http:';
            // case ScriptLoaderProtocol.HTTPS:
            default:
                return 'https:';
        }
    };
    LazyGoogleMapsApiLoader.prototype.getQueryParams = function (callbackName) {
        var queryParams = {
            v: this._options.apiVersion,
            callback: callbackName
        };
        if (this._options.apiKey) {
            queryParams['key'] = this._options.apiKey;
        }
        if (this._options.libraries && this._options.libraries.length) {
            queryParams['libraries'] = this._options.libraries.join(',');
        }
        if (this._options.region) {
            queryParams['region'] = this._options.region;
        }
        if (this._options.language) {
            queryParams['language'] = this._options.language;
        }
        var params = [];
        Object.keys(queryParams)
            .forEach(function (key) {
            params.push(key + "=" + queryParams[key]);
        });
        return "?" + params.join('&');
    };
    return LazyGoogleMapsApiLoader;
}(BaseGoogleMapsApiLoader));
exports.LazyGoogleMapsApiLoader = __decorate$2([
    _angular_core.Injectable(),
    __param$1(0, _angular_core.Inject(LAZY_LOADER_OPTIONS)),
    __metadata$2("design:paramtypes", [Object])
], exports.LazyGoogleMapsApiLoader);

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Created by mjaric on 9/28/16.
 */
// import {BaseGoogleMapsApiLoader} from '../loaders/base-google-maps-api-loader';
var DefaultCoords = {
    latitude: 40.730610,
    longitude: -73.935242
};
var DEFAULT_MAP_OPTIONS = {
    zoom: 10,
    zoomControl: false,
    mapTypeControl: false,
    streetViewControl: false
};
function noop() {
}
/**
 * Service responsible to execute arbitrary functions in specific google map context
 */
exports.MapsManager = (function () {
    function MapsManager(loader) {
        this.loader = loader;
        this._maps = new Map();
        // check browser location
        this.getBrowserLocation()
            .then(noop);
        // preload map immediately
        this.loader
            .load()
            .then(noop);
    }
    MapsManager.prototype.onApiLoad = function () {
        return this
            .loader
            .load();
    };
    MapsManager.prototype.createMarker = function (options) {
        return this
            .loader
            .load()
            .then(function () { return new google.maps.Marker(options); });
    };
    MapsManager.prototype.createDirections = function (options) {
        return this.loader
            .load()
            .then(function () {
            return new google.maps.DirectionsRenderer(options);
        });
    };
    MapsManager.prototype.getDirections = function (origin, destination) {
        return this
            .loader
            .load()
            .then(function () {
            var svc = new google.maps.DirectionsService();
            return new Promise(function (resolve, reject) {
                var request = {
                    origin: new google.maps.LatLng(origin.lat || origin.latitude, origin.lng || origin.longitude),
                    destination: new google.maps.LatLng(destination.lat || destination.latitude, destination.lng || destination.longitude),
                    travelMode: google.maps.TravelMode.DRIVING
                };
                svc.route(request, function (result, status) {
                    if (status === google.maps.DirectionsStatus.OK) {
                        resolve(result);
                    }
                    else {
                        console.error({ message: 'fail to get directions', status: status, result: result });
                        reject({ status: status, result: result });
                    }
                });
            });
        });
    };
    MapsManager.prototype.createMap = function (el, options) {
        var _this = this;
        return this.loader
            .load()
            .then(function () {
            return _this.getBrowserLocation()
                .then(function (coords) {
                options = Object.assign({}, options, DEFAULT_MAP_OPTIONS, {
                    center: new google.maps.LatLng(coords.latitude, coords.longitude),
                    zoom: 8
                });
                return new google.maps.Map(el, options);
            });
        });
    };
    MapsManager.prototype.getMap = function (name) {
        var _this = this;
        return this.loader
            .load()
            .then(function () { return _this._maps.get(name); });
    };
    MapsManager.prototype.addMap = function (name, map) {
        this._maps.set(name, map);
    };
    MapsManager.prototype.removeMap = function (name) {
        return this._maps.delete(name);
    };
    MapsManager.prototype.createAutocomplete = function (input, options) {
        return this.loader.load().then(function () {
            return new google.maps.places.Autocomplete(input.nativeElement, options);
        });
    };
    MapsManager.prototype.getBrowserLocation = function () {
        if (this._browserLocationPromise) {
            return (this._browserLocationPromise);
        }
        return this._browserLocationPromise = new Promise(function (resolve) {
            if (location.protocol === 'https' && navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function (success) {
                    resolve(success.coords);
                }, function (error) {
                    console.error(error);
                    if (error.code !== PositionError.PERMISSION_DENIED) {
                        console.warn("Permission is accepted but error encounter with message: " + error.message);
                    }
                    // if user didn't answer return default
                    resolve(DefaultCoords);
                });
            }
            else {
                // if browser do not support location API return default (NYC)
                resolve(DefaultCoords);
            }
        });
    };
    MapsManager.prototype.calculateMapBounds = function (markers) {
        if (markers === void 0) { markers = []; }
        return this.loader.load().then(function () {
            return new Promise(function (resolve, reject) {
                if (markers && markers.length > 1) {
                    var latLng = new google.maps.LatLng(markers[0].latitude, markers[0].longitude);
                    var bounds = new google.maps.LatLngBounds(latLng);
                    for (var i = 1; i < markers.length; i++) {
                        var marker = markers[i];
                        bounds.extend(new google.maps.LatLng(marker.latitude, marker.longitude));
                    }
                    resolve(bounds);
                    return;
                }
                reject({ error: 'There is no markers in markers array', centerTo: DefaultCoords });
                return;
            });
        });
    };
    return MapsManager;
}());
exports.MapsManager = __decorate$1([
    _angular_core.Injectable(),
    __metadata$1("design:paramtypes", [exports.LazyGoogleMapsApiLoader])
], exports.MapsManager);

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Created by mjaric on 9/28/16.
 */
exports.GoogleMapComponent = GoogleMapComponent_1 = (function () {
    function GoogleMapComponent(_name, _elem, _mapsManager) {
        var _this = this;
        this._name = _name;
        this._elem = _elem;
        this._mapsManager = _mapsManager;
        /**
         * Should map auto resize bounds to current set of markers
         * @type {boolean} default is true
         */
        this.autoFitMarkers = true;
        this._id = GoogleMapComponent_1.counters++;
        this._map = new Promise(function (resolve) { return _this._mapResolver = resolve; });
    }
    GoogleMapComponent.prototype.getMap = function () {
        return this._map;
    };
    Object.defineProperty(GoogleMapComponent.prototype, "backgroundColor", {
        get: function () {
            return this._backgroundColor;
        },
        /**
         * Color used for the background of the Map div.
         * This color will be visible when tiles have not yet loaded as the user pans.
         * Note: This option can only be set when the map is initialized.
         */
        set: function (value) {
            if (this._backgroundColor) {
                console.warn('Option "backgroundColor" can only be set when the map is initialized');
                return;
            }
            this._backgroundColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "center", {
        get: function () {
            return this._center;
        },
        /**
         * The initial Map center. Required.
         */
        set: function (value) {
            this._map.then(function (map) {
                if (value) {
                    map.setCenter({
                        lat: value.lat || value.latitude,
                        lng: value.lng || value.longitude
                    });
                }
            });
            this._center = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "disableDoubleClickZoom", {
        get: function () {
            return this._disableDoubleClickZoom;
        },
        /**
         * Enables/disables zoom and center on double click. Enabled by default.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ disableDoubleClickZoom: mode }); });
            this._disableDoubleClickZoom = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "draggable", {
        get: function () {
            return this._draggable;
        },
        /**
         * If false, prevents the map from being dragged.
         * Dragging is enabled by default.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ draggable: mode }); });
            this._draggable = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "keyboardShortcuts", {
        get: function () {
            return this._keyboardShortcuts;
        },
        /**
         * If false, prevents the map from being controlled by the keyboard.
         * Keyboard shortcuts are enabled by default.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ keyboardShortcuts: mode }); });
            this._keyboardShortcuts = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "scrollwheel", {
        get: function () {
            return this._scrollwheel;
        },
        /**
         * If false, disables scrollwheel zooming on the map.
         * The scrollwheel is enabled by default.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ scrollwheel: mode }); });
            this._scrollwheel = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "zoom", {
        get: function () {
            return this._zoom;
        },
        /*
         * Zoom options
         * **********************************************************
         */
        /**
         * Map zoom level.
         */
        set: function (value) {
            this._map.then(function (map) { return map.setZoom(value); });
            this._zoom = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "minZoom", {
        get: function () {
            return this._minZoom;
        },
        /**
         * The maximum zoom level which will be displayed on the map.
         */
        set: function (value) {
            this._map.then(function (map) { return map.setOptions({ minZoom: value }); });
            this._minZoom = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "maxZoom", {
        get: function () {
            return this._maxZoom;
        },
        /**
         * The minimum zoom level which will be displayed on the map.
         */
        set: function (value) {
            this._map.then(function (map) { return map.setOptions({ maxZoom: value }); });
            this._maxZoom = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "disableDefaultUI", {
        get: function () {
            return this._disableDefaultUI;
        },
        /*
         * Control options
         * **********************************************************
         */
        /**
         * Enables/disables all default UI.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ disableDefaultUI: mode }); });
            this._disableDefaultUI = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "mapTypeControl", {
        get: function () {
            return this._mapTypeControl;
        },
        /**
         * Enabled/Disabled state of the Map type control.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ mapTypeControl: mode }); });
            this._mapTypeControl = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "rotateControl", {
        get: function () {
            return this._rotateControl;
        },
        /**
         * Enabled/Disabled state of the Rotate control.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ rotateControl: mode }); });
            this._rotateControl = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "scaleControl", {
        get: function () {
            return this._scaleControl;
        },
        /**
         * Enabled/Disabled state of the Scale control.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ scaleControl: mode }); });
            this._scaleControl = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "streetViewControl", {
        get: function () {
            return this._streetViewControl;
        },
        /**
         * Enabled/Disabled state of the Street View Pegman control.
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ streetViewControl: mode }); });
            this._streetViewControl = mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapComponent.prototype, "zoomControl", {
        get: function () {
            return this._zoomControl;
        },
        /**
         * Enabled/Disabled state of the Zoom control
         */
        set: function (mode) {
            this._map.then(function (map) { return map.setOptions({ zoomControl: mode }); });
            this._zoomControl = mode;
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Internal logic
     * **********************************************************
     */
    GoogleMapComponent.prototype.ngOnInit = function () {
        var _this = this;
        this._mapsManager
            .createMap(this._elem.nativeElement.querySelector('.google-map-container'), this.getOptions())
            .then(function (map) {
            _this._mapsManager.addMap(_this.toString(), map);
            _this._mapResolver(map);
        });
    };
    GoogleMapComponent.prototype.ngOnDestroy = function () {
        this._mapsManager.removeMap(this._name);
        this._mapComponentsSubscriptions.unsubscribe();
    };
    GoogleMapComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        this._mapComponentsSubscriptions = this.mapComponents.changes.subscribe(function () {
            _this.attachComponentsToMap();
        });
        this.attachComponentsToMap();
    };
    GoogleMapComponent.prototype.toString = function () {
        return this._name ? this._name : "fh.google-maps-" + this._id;
    };
    GoogleMapComponent.prototype.attachComponentsToMap = function () {
        var _this = this;
        this._map.then(function (map) {
            _this.mapComponents
                .filter(function (v) { return !v.hasMapComponent(); })
                .forEach(function (v) {
                v.setMapComponent(_this, map);
            });
        });
    };
    GoogleMapComponent.prototype.getOptions = function () {
        return {
            center: { lat: 0, lng: 0 },
            zoom: 5,
            backgroundColor: this._backgroundColor
        };
    };
    GoogleMapComponent.prototype.resetMapBounds = function (bounds) {
        this._map.then(function (map) {
            map.fitBounds(bounds);
        });
    };
    GoogleMapComponent.prototype.fitBounds = function (bounds) {
        this.resetMapBounds(bounds);
    };
    return GoogleMapComponent;
}());
exports.GoogleMapComponent.counters = 0;
__decorate([
    _angular_core.ContentChildren(_angular_core.forwardRef(function () { return BaseGoogleMapComponent; }), {}),
    __metadata("design:type", _angular_core.QueryList)
], exports.GoogleMapComponent.prototype, "mapComponents", void 0);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean)
], exports.GoogleMapComponent.prototype, "autoFitMarkers", void 0);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], exports.GoogleMapComponent.prototype, "backgroundColor", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], exports.GoogleMapComponent.prototype, "center", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "disableDoubleClickZoom", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "draggable", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "keyboardShortcuts", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "scrollwheel", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], exports.GoogleMapComponent.prototype, "zoom", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], exports.GoogleMapComponent.prototype, "minZoom", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], exports.GoogleMapComponent.prototype, "maxZoom", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "disableDefaultUI", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "mapTypeControl", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "rotateControl", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "scaleControl", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "streetViewControl", null);
__decorate([
    _angular_core.Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], exports.GoogleMapComponent.prototype, "zoomControl", null);
exports.GoogleMapComponent = GoogleMapComponent_1 = __decorate([
    _angular_core.Component({
        selector: 'google-map',
        template: "\n        <div class=\"google-map-container\" style=\"width: inherit; height: inherit\"></div>\n        <ng-content></ng-content>\n    "
    }),
    __param(0, _angular_core.Attribute('name')),
    __metadata("design:paramtypes", [String, _angular_core.ElementRef,
        exports.MapsManager])
], exports.GoogleMapComponent);
var GoogleMapComponent_1;

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$3 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Created by mjaric on 9/30/16.
 */
exports.GoogleMapDirectionsDirective = GoogleMapDirectionsDirective_1 = (function (_super) {
    __extends$1(GoogleMapDirectionsDirective, _super);
    function GoogleMapDirectionsDirective(_mapsManager) {
        var _this = _super.call(this) || this;
        _this._mapsManager = _mapsManager;
        _this._routeColor = '#ff9702';
        /**
         * This event is fired when the directions route changes.
         */
        _this.directions_changed = new _angular_core.EventEmitter();
        /**
         * By default, the input map is centered and zoomed to the bounding box of this set of directions.
         * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom were never set.
         * @type {boolean}
         */
        _this.preserveViewport = true;
        return _this;
    }
    Object.defineProperty(GoogleMapDirectionsDirective.prototype, "origin", {
        /**
         * Origin of directions
         * @param value can be google.maps.LatLngLiteral or Coordinates  or {latitude: number, longitude: number}
         */
        set: function (value) {
            var _this = this;
            if (this._origin !== value) {
                this._origin = value;
                if (this._destination) {
                    this._mapsManager
                        .getDirections(this._origin, this._destination)
                        .then(function (directions) {
                        _this.proxy
                            .then(function (renderer) {
                            renderer.setDirections(directions);
                        });
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapDirectionsDirective.prototype, "destination", {
        /**
         * Destination of directions
         * @param value can be google.maps.LatLngLiteral or Coordinates  or {latitude: number, longitude: number}
         */
        set: function (value) {
            var _this = this;
            if (this._destination !== value) {
                this._destination = value;
                if (this._origin) {
                    this._mapsManager
                        .getDirections(this._origin, this._destination)
                        .then(function (directions) {
                        _this.proxy
                            .then(function (renderer) {
                            renderer.setDirections(directions);
                        });
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapDirectionsDirective.prototype, "routeColor", {
        /**
         * Sets the color of rendered polygonal line as route in map view
         * @param value is as string e.g. '#ff9702'. Default value is '#ff9702'
         */
        set: function (value) {
            var _this = this;
            this._routeColor = value || '#ff9702';
            this.proxy.then(function (directions) {
                directions.setOptions(_this.getOptions());
            });
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Internal logic
     * **********************************************************
     */
    GoogleMapDirectionsDirective.prototype.ngOnInit = function () {
        var _this = this;
        this._mapsManager
            .createDirections()
            .then(function (directionsRenderer) {
            _this.bindEvents(directionsRenderer);
            _this.proxyResolver(directionsRenderer);
        });
    };
    GoogleMapDirectionsDirective.prototype.ngOnDestroy = function () {
        this.proxy.then(function (directions) {
            google.maps.event.clearInstanceListeners(directions);
            directions.setMap(null);
        });
    };
    GoogleMapDirectionsDirective.prototype.bindEvents = function (directions) {
        var _this = this;
        directions.addListener('directions_changed', function (e) { return _this.directions_changed.emit(e); });
    };
    GoogleMapDirectionsDirective.prototype.getOptions = function () {
        return {
            preserveViewport: this.preserveViewport,
            suppressMarkers: true,
            polylineOptions: {
                strokeColor: this._routeColor
            }
        };
    };
    return GoogleMapDirectionsDirective;
}(BaseGoogleMapComponent));
__decorate$3([
    _angular_core.Input(),
    __metadata$3("design:type", Object),
    __metadata$3("design:paramtypes", [Object])
], exports.GoogleMapDirectionsDirective.prototype, "origin", null);
__decorate$3([
    _angular_core.Input(),
    __metadata$3("design:type", Object),
    __metadata$3("design:paramtypes", [Object])
], exports.GoogleMapDirectionsDirective.prototype, "destination", null);
__decorate$3([
    _angular_core.Input(),
    __metadata$3("design:type", String),
    __metadata$3("design:paramtypes", [String])
], exports.GoogleMapDirectionsDirective.prototype, "routeColor", null);
__decorate$3([
    _angular_core.Output(),
    __metadata$3("design:type", _angular_core.EventEmitter)
], exports.GoogleMapDirectionsDirective.prototype, "directions_changed", void 0);
__decorate$3([
    _angular_core.Input(),
    __metadata$3("design:type", Boolean)
], exports.GoogleMapDirectionsDirective.prototype, "preserveViewport", void 0);
exports.GoogleMapDirectionsDirective = GoogleMapDirectionsDirective_1 = __decorate$3([
    _angular_core.Directive({
        selector: 'google-map-directions',
        providers: [{ provide: BaseGoogleMapComponent, useExisting: _angular_core.forwardRef(function () { return GoogleMapDirectionsDirective_1; }) }]
    }),
    __metadata$3("design:paramtypes", [exports.MapsManager])
], exports.GoogleMapDirectionsDirective);
var GoogleMapDirectionsDirective_1;

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$4 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Created by mjaric on 9/28/16.
 */
exports.GoogleMapMakerDirective = GoogleMapMakerDirective_1 = (function (_super) {
    __extends$2(GoogleMapMakerDirective, _super);
    function GoogleMapMakerDirective(_mapsManager) {
        var _this = _super.call(this) || this;
        _this._mapsManager = _mapsManager;
        /*
         * Outputs events
         * **********************************************************
         */
        /**
         * This event is fired when the marker icon was clicked.
         */
        _this.click = new _angular_core.EventEmitter();
        /**
         * This event is fired when the marker icon was double clicked.
         */
        _this.dblclick = new _angular_core.EventEmitter();
        /**
         * This event is fired for a rightclick on the marker.
         */
        _this.rightclick = new _angular_core.EventEmitter();
        /**
         * This event is fired when the marker position property changes.
         */
        _this.position_changed = new _angular_core.EventEmitter();
        /**
         * This event is fired when the marker icon property changes.
         */
        _this.icon_changed = new _angular_core.EventEmitter();
        /**
         * This event is fired when the marker title property changes.
         */
        _this.title_changed = new _angular_core.EventEmitter();
        /**
         * This event is fired when the marker visible property changes.
         */
        _this.visible_changed = new _angular_core.EventEmitter();
        return _this;
    }
    Object.defineProperty(GoogleMapMakerDirective.prototype, "position", {
        /*
         * Inputs options
         * **********************************************************
         */
        /**
         * Marker position
         */
        set: function (value) {
            this.proxy.then(function (marker) {
                var position = new google.maps.LatLng(value.lat || value.latitude, value.lng || value.longitude);
                marker.setPosition(position);
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapMakerDirective.prototype, "clickable", {
        /**
         * If true, the marker receives mouse and touch events.
         * Default value is true.
         */
        set: function (mode) {
            this.proxy.then(function (marker) { return marker.setClickable(mode); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapMakerDirective.prototype, "icon", {
        /**
         * Icon for the foreground. If a string is provided,
         * it is treated as though it were an Icon with the string as url.
         */
        set: function (value) {
            this.proxy.then(function (marker) { return marker.setIcon(value); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapMakerDirective.prototype, "opacity", {
        /**
         * The marker's opacity between 0.0 and 1.0.
         */
        set: function (value) {
            this.proxy.then(function (marker) { return marker.setOpacity(value); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapMakerDirective.prototype, "title", {
        /**
         * Rollover text
         */
        set: function (value) {
            this.proxy.then(function (marker) { return marker.setTitle(value); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapMakerDirective.prototype, "visible", {
        /**
         * If true, the marker is visible
         */
        set: function (mode) {
            this.proxy.then(function (marker) { return marker.setVisible(mode); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapMakerDirective.prototype, "zIndex", {
        /**
         * Set marker zIndex for displayed on the map
         */
        set: function (value) {
            this.proxy.then(function (marker) { return marker.setZIndex(value); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapMakerDirective.prototype, "animation", {
        set: function (value) {
            this.proxy.then(function (marker) { return marker.setAnimation(value); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GoogleMapMakerDirective.prototype, "setDelay", {
        set: function (value) {
            this.delay = value;
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Internal logic
     * **********************************************************
     */
    GoogleMapMakerDirective.prototype.ngOnInit = function () {
        var _this = this;
        this._mapsManager.createMarker()
            .then(function (marker) {
            _this.bindEvents(marker);
            _this.proxyResolver(marker);
        });
    };
    GoogleMapMakerDirective.prototype.ngOnDestroy = function () {
        this.proxy.then(function (marker) {
            google.maps.event.clearInstanceListeners(marker);
            marker.setMap(null);
        });
    };
    GoogleMapMakerDirective.prototype.bindEvents = function (marker) {
        var _this = this;
        marker.addListener('click', function (e) { return _this.click.emit(e); });
        marker.addListener('dblclick', function (e) { return _this.dblclick.emit(e); });
        marker.addListener('rightclick', function (e) { return _this.rightclick.emit(e); });
        marker.addListener('position_changed', function (e) { return _this.position_changed.emit(e); });
        marker.addListener('title_changed', function (e) { return _this.title_changed.emit(e); });
        marker.addListener('icon_changed', function (e) { return _this.icon_changed.emit(e); });
        marker.addListener('visible_changed', function (e) { return _this.visible_changed.emit(e); });
    };
    return GoogleMapMakerDirective;
}(BaseGoogleMapComponent));
__decorate$4([
    _angular_core.Output(),
    __metadata$4("design:type", _angular_core.EventEmitter)
], exports.GoogleMapMakerDirective.prototype, "click", void 0);
__decorate$4([
    _angular_core.Output(),
    __metadata$4("design:type", _angular_core.EventEmitter)
], exports.GoogleMapMakerDirective.prototype, "dblclick", void 0);
__decorate$4([
    _angular_core.Output(),
    __metadata$4("design:type", _angular_core.EventEmitter)
], exports.GoogleMapMakerDirective.prototype, "rightclick", void 0);
__decorate$4([
    _angular_core.Output(),
    __metadata$4("design:type", _angular_core.EventEmitter)
], exports.GoogleMapMakerDirective.prototype, "position_changed", void 0);
__decorate$4([
    _angular_core.Output(),
    __metadata$4("design:type", _angular_core.EventEmitter)
], exports.GoogleMapMakerDirective.prototype, "icon_changed", void 0);
__decorate$4([
    _angular_core.Output(),
    __metadata$4("design:type", _angular_core.EventEmitter)
], exports.GoogleMapMakerDirective.prototype, "title_changed", void 0);
__decorate$4([
    _angular_core.Output(),
    __metadata$4("design:type", _angular_core.EventEmitter)
], exports.GoogleMapMakerDirective.prototype, "visible_changed", void 0);
__decorate$4([
    _angular_core.Input(),
    __metadata$4("design:type", Object),
    __metadata$4("design:paramtypes", [Object])
], exports.GoogleMapMakerDirective.prototype, "position", null);
__decorate$4([
    _angular_core.Input(),
    __metadata$4("design:type", Boolean),
    __metadata$4("design:paramtypes", [Boolean])
], exports.GoogleMapMakerDirective.prototype, "clickable", null);
__decorate$4([
    _angular_core.Input(),
    __metadata$4("design:type", Object),
    __metadata$4("design:paramtypes", [Object])
], exports.GoogleMapMakerDirective.prototype, "icon", null);
__decorate$4([
    _angular_core.Input(),
    __metadata$4("design:type", Number),
    __metadata$4("design:paramtypes", [Number])
], exports.GoogleMapMakerDirective.prototype, "opacity", null);
__decorate$4([
    _angular_core.Input(),
    __metadata$4("design:type", String),
    __metadata$4("design:paramtypes", [String])
], exports.GoogleMapMakerDirective.prototype, "title", null);
__decorate$4([
    _angular_core.Input(),
    __metadata$4("design:type", Boolean),
    __metadata$4("design:paramtypes", [Boolean])
], exports.GoogleMapMakerDirective.prototype, "visible", null);
__decorate$4([
    _angular_core.Input(),
    __metadata$4("design:type", Number),
    __metadata$4("design:paramtypes", [Number])
], exports.GoogleMapMakerDirective.prototype, "zIndex", null);
__decorate$4([
    _angular_core.Input(),
    __metadata$4("design:type", Number),
    __metadata$4("design:paramtypes", [Number])
], exports.GoogleMapMakerDirective.prototype, "animation", null);
__decorate$4([
    _angular_core.Input('delay'),
    __metadata$4("design:type", Number),
    __metadata$4("design:paramtypes", [Number])
], exports.GoogleMapMakerDirective.prototype, "setDelay", null);
exports.GoogleMapMakerDirective = GoogleMapMakerDirective_1 = __decorate$4([
    _angular_core.Directive({
        selector: 'google-map-marker',
        providers: [{ provide: BaseGoogleMapComponent, useExisting: _angular_core.forwardRef(function () { return GoogleMapMakerDirective_1; }) }]
    }),
    __metadata$4("design:paramtypes", [exports.MapsManager])
], exports.GoogleMapMakerDirective);
var GoogleMapMakerDirective_1;

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$5 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Created by Bosko-Vibe on 7.11.2016.
 */
exports.GoogleMapPolylineDirective = GoogleMapPolylineDirective_1 = (function (_super) {
    __extends$3(GoogleMapPolylineDirective, _super);
    function GoogleMapPolylineDirective(mapsManager) {
        var _this = _super.call(this) || this;
        mapsManager
            .onApiLoad()
            .then(function () {
            _this.proxyResolver(new google.maps.Polyline());
        });
        return _this;
    }
    Object.defineProperty(GoogleMapPolylineDirective.prototype, "options", {
        set: function (value) {
            this.proxy.then(function (o) { return o.setOptions(value); });
        },
        enumerable: true,
        configurable: true
    });
    GoogleMapPolylineDirective.prototype.ngOnDestroy = function () {
        this.proxy
            .then(function (p) {
            p.setMap(null);
            p.setPath([]);
        });
    };
    return GoogleMapPolylineDirective;
}(BaseGoogleMapComponent));
__decorate$5([
    _angular_core.Input(),
    __metadata$5("design:type", Object),
    __metadata$5("design:paramtypes", [Object])
], exports.GoogleMapPolylineDirective.prototype, "options", null);
exports.GoogleMapPolylineDirective = GoogleMapPolylineDirective_1 = __decorate$5([
    _angular_core.Directive({
        selector: 'google-map-polyline',
        providers: [{ provide: BaseGoogleMapComponent, useExisting: _angular_core.forwardRef(function () { return GoogleMapPolylineDirective_1; }) }]
    }),
    __metadata$5("design:paramtypes", [exports.MapsManager])
], exports.GoogleMapPolylineDirective);
var GoogleMapPolylineDirective_1;

// Export all directives

var NoopGoogleMapsApiLoader = (function () {
    function NoopGoogleMapsApiLoader() {
    }
    NoopGoogleMapsApiLoader.prototype.load = function () {
        if (!(google && google.maps)) {
            return Promise.reject('Google Maps API not loaded on page. Make sure window.google.maps is available!');
        }
        else {
            return Promise.resolve();
        }
    };
    return NoopGoogleMapsApiLoader;
}());

// Import all services
/**
 * The following list shows the approximate level of detail
 * you can expect to see at each zoom level
 */
var ZoomLevel = {
    World: 1,
    Continent: 5,
    City: 10,
    Streets: 15,
    Buildings: 20
};
/**
 * Animations that can be played on a marker.
 * @see https://developers.google.com/maps/documentation/javascript/reference?hl=ru#Animation
 */
var Animation = {
    /**
     * Marker bounces until animation is stopped.
     */
    BOUNCE: 1,
    /**
     * Marker falls from the top of the map ending with a small bounce.
     */
    DROP: 2
};

var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Factory function which builds handler for application initialization
 * @param loader instance of loader, should be passed as dependency
 * @returns {()=>Promise<any>} function is executed by angular application initializer
 * @constructor
 */
function MapsApiLoaderFactory(loader) {
    return function () {
        return loader.load();
    };
}
exports.GoogleMapsNg2Module = GoogleMapsNg2Module_1 = (function () {
    function GoogleMapsNg2Module() {
    }
    /**
     * Used to register in top level or shared module in your application. Loader Options are mandatory.
     * {@expample
import {NgModule, NgModule} from '@angular/core';
     *
     *  @NgModule({
     *      declarations: [...],
     *      imports: [
     *          ...
     *          GoogleMapsNg2Module.forRoot(<LoaderOptions>{
     *              apiKey: "your google maps API key
     *              libraries: ["places", "geometry"]
     *          }),
     *          ...
     *     ],
     *     // optional, you can import module like below if your module depends only on component and directives
     *     exports: [
     *      GoogleMapsNg2Module
     *     ]
     *  })
     *  export class MySharedModule { }
     * }
     *
     * @param loaderOptions
     * @returns {ModuleWithProviders}
     */
    GoogleMapsNg2Module.forRoot = function (loaderOptions) {
        return {
            ngModule: GoogleMapsNg2Module_1,
            providers: [
                {
                    provide: LAZY_LOADER_OPTIONS,
                    useValue: loaderOptions
                },
                exports.LazyGoogleMapsApiLoader,
                {
                    provide: _angular_core.APP_INITIALIZER,
                    useFactory: MapsApiLoaderFactory,
                    deps: [exports.LazyGoogleMapsApiLoader],
                    multi: true
                },
                { provide: exports.MapsManager, useClass: exports.MapsManager }
            ]
        };
    };
    return GoogleMapsNg2Module;
}());
exports.GoogleMapsNg2Module = GoogleMapsNg2Module_1 = __decorate$6([
    _angular_core.NgModule({
        declarations: [
            exports.GoogleMapComponent,
            exports.GoogleMapDirectionsDirective,
            exports.GoogleMapMakerDirective,
            exports.GoogleMapPolylineDirective
        ],
        exports: [
            exports.GoogleMapComponent,
            exports.GoogleMapDirectionsDirective,
            exports.GoogleMapMakerDirective,
            exports.GoogleMapPolylineDirective
        ]
    })
], exports.GoogleMapsNg2Module);
var GoogleMapsNg2Module_1;

exports.BaseGoogleMapComponent = BaseGoogleMapComponent;
exports.BaseGoogleMapsApiLoader = BaseGoogleMapsApiLoader;
exports.LAZY_LOADER_OPTIONS = LAZY_LOADER_OPTIONS;
exports.NoopGoogleMapsApiLoader = NoopGoogleMapsApiLoader;
exports.Animation = Animation;
exports.ZoomLevel = ZoomLevel;
exports.MapsApiLoaderFactory = MapsApiLoaderFactory;

Object.defineProperty(exports, '__esModule', { value: true });

})));
